# STM32F103C8T6 工业电源保护系统

## 项目概述

这是一个基于STM32F103C8T6的工业电源保护系统固件。系统监测总线电压（48V-51V范围，带迟滞），通过PWM和GPIO控制功率切换。设计优先考虑确定性行为和硬件驱动的时序，而非软件便利性。

### 核心特性

- **UART调试输出**：USART2（PA2/PA3），115200波特率，printf重定向，实时状态上报
- **硬件触发的ADC采样**：TIM2_CC2以1kHz触发ADC，DMA循环模式传输数据，采样引脚PA5
- **软件滤波器**：16样本滑动平均，消除ADC噪声和悬空波动
- **迟滞电压保护**：48V以下导通，51V以上关断，48-51V之间维持状态
- **双重控制输出**：PA4（GPIO）+ TIM3_CH3/PB0（PWM），实现冗余控制
- **实时OLED显示**：电压、状态、ADC原始值、诊断信息，右侧LUX标识
- **零RTOS设计**：纯中断+主循环架构，确保确定性

---

## 硬件接线说明

### 引脚定义

| 功能 | 引脚 | 模式 | 说明 |
|------|------|------|------|
| **UART TX** | PA2 | 复用推挽 | USART2发送，接USB-TTL的RX |
| **UART RX** | PA3 | 输入 | USART2接收，接USB-TTL的TX |
| **控制输出** | PA4 | 推挽输出 | 低电平有效：LOW=导通，HIGH=关断 |
| **ADC输入** | PA5 | 模拟输入 | 电压采样输入（ADC1_IN5，经过分压电路） |
| **PWM输出** | PB0 | 复用推挽 | TIM3_CH3，10kHz PWM，低电平有效 |
| **I2C SCL** | PB6 | 开漏输出 | OLED时钟线（内部上拉） |
| **I2C SDA** | PB7 | 开漏输出 | OLED数据线（内部上拉） |

### 电路连接要求

#### 1. 电压采样电路（PA5）

```
总线电压 ────[分压电阻1]────┬────[分压电阻2]──── GND
                            │
                            ├────[滤波电容]──── GND (可选)
                            │
                            └──── PA5 (ADC1_IN5)
```

**参数计算**：
- 目标测量范围：48V - 51V
- ADC参考电压：3.3V
- 分压比要求：`R2 / (R1 + R2) = 3.3 / 51 ≈ 1/15.5`
- **实际使用分压比**：1/25（代码中`Vbus = Vadc * 25`）

**推荐值**：
- R1（上分压）：240kΩ（耐压≥100V）
- R2（下分压）：10kΩ（1%精度）
- 滤波电容：100nF（并联在R2两端，滤除高频噪声）

**抗干扰措施**（重要！）：

| 场景 | 推荐方案 | 说明 |
|------|----------|------|
| **正常工作**（R2=10kΩ） | 无需额外措施 | R2已提供到GND路径，软件滤波足够 |
| **高阻抗分压**（R2>47kΩ） | 添加10kΩ并联下拉 | 增强抗干扰能力，防止悬空噪声 |
| **高噪声环境** | 软件+硬件双保险 | 10kΩ下拉 + 软件滤波器 |
| **测试阶段** | 仅软件滤波 | 已内置，无需硬件改动 |

**下拉电阻选型指南**：
```
正常情况（R2=10kΩ）：
  PA5 ─┬─ 10kΩ ── GND (R2)
       └─ (无需额外下拉)

高阻抗情况（R2=100kΩ）：
  PA5 ─┬─ 100kΩ ── GND (R2)
       ├─ 10kΩ ── GND (新增，并联)
       └─ 结果：等效9.1kΩ到GND
```

**软件滤波器**（已实现）：
- 算法：16样本滑动平均
- 采样率：1kHz（TIM2触发）
- 滤波周期：16ms
- 初始化：使用独立计数器 `filter_count`，确保缓冲区完全填满后才标记初始化完成
- 效果：自动消除随机噪声，读数稳定

#### 2. 控制输出（PA4 + PB0）

外部门驱动为**低电平有效**：
- **LOW** = 导通（ON）
- **HIGH** = 关断（OFF）

**安全默认状态**（复位后）：
- PA4 = HIGH（OFF）
- PWM（PB0）= 100%占空比（恒定HIGH/OFF，CCR3=7200）

**连接方式**：
```
          STM32F103C8T6
        ┌──────────────┐
PA4 ────┤ GPIO控制     ├───┐
        │              │   │
PB0 ────┤ PWM输出     ├───┼───┬──→ 外部门驱动电路
        │              │   │   │
GND ────┤ GND          ├───┴───┘
        └──────────────┘
```

两个输出应在外部硬件连接（二极管OR门或直接并联），确保任一输出为HIGH时系统关断。

#### 3. UART调试接口（PA2/PA3）

```
          STM32F103C8T6        USB-TTL模块
        ┌──────────────┐      ┌──────────┐
PA2 TX ─┤              ├──→───┤ RX       ├─── USB → PC
PA3 RX ─┤              ├──←───┤ TX       │
GND ────┤ GND          ├──────┤ GND      │
        └──────────────┘      └──────────┘
```

**串口参数**：115200-8N1，无流控

**调试输出示例**：
```
========================================
Power Protection System v2.0
ADC: PA5/CH5, PWM: PB0/CH3, GPIO: PA4
UART: PA2/PA3 @ 115200
========================================
[STATE] CUTOFF
[MONITOR] Vbus=52.3V ADC=516 State=CUTOFF
[STATE] CONDUCTION
[MONITOR] Vbus=46.8V ADC=462 State=CONDUCTION
```

#### 4. OLED显示屏（SSD1306，128x64）

**I2C接口**：
- PB6 → SCL
- PB7 → SDA
- 电源：3.3V + GND
- 默认I2C地址：0x78

**屏幕布局**（4行×16字符）：

```
┌──────────────────────┐
│Vbus:XX.XV         L │  第1行：总线电压 + L
│State:ON 0%        U │  第2行：系统状态 + U
│ADC:XXX            X │  第3行：ADC原始值 + X
│TER111(48,51)        │  第4行：诊断信息+阈值
└──────────────────────┘
```

**右侧LUX标识**：
- 第1-3行最右侧显示L、U、X
- 垂直对齐形成"LUX"字样
- 用于标识当前显示界面

---

## OLED显示参数说明

### 第1行：Vbus（总线电压）

```
格式：Vbus:XX.XV
示例：Vbus:48.5V
显示：Vbus:48.5V         L
```

- 显示实际总线电压（经过×25分压比计算）
- 精度：0.1V
- 测量范围：0V - 82.5V（ADC满量程3.3V × 25）
- **右侧"L"**：LUX标识第一部分

### 第2行：State（系统状态）

```
State:ON 0%    ← 导通状态，GPIO=LOW，PWM=0%
State:OFF 100% ← 关断状态，GPIO=HIGH，PWM=100%
显示：State:ON 0%        U
      State:OFF 100%    U
```

- **ON（导通）**：PA4=LOW，TIM3_CH3 CCR3=0（恒定LOW）
- **OFF（关断）**：PA4=HIGH，TIM3_CH3 CCR3=7200（恒定HIGH）
- 48V以下自动切换至ON
- 51V以上自动切换至OFF
- 48-51V之间维持当前状态（迟滞区）
- **右侧"U"**：LUX标识第二部分

### 第3行：ADC（原始采样值）

```
格式：ADC:XXX
示例：ADC:450
范围：0 - 4095（12位ADC）
显示：ADC:450            X
```

- 显示经过**16样本滑动平均滤波**后的ADC值
- 硬件采样：8次DMA采集 @ 1kHz
- 软件滤波：16样本滑动平均（总周期16ms）
- 对应电压计算：`Vbus = (ADC / 4095 × 3.3V) × 25`
- **接地时应显示接近0**（软件滤波会消除悬空噪声）
- 48V对应约ADC=400-450
- 51V对应约ADC=425-475
- **右侧"X"**：LUX标识第三部分，与L、U垂直对齐形成"LUX"

### 第4行：诊断信息+阈值

```
格式：TERxyz(下限,上限)
示例：TER111(48,51)
说明：括号内显示实际的阈值变量值
```

| 参数 | 含义 | 正常值 | 异常含义 |
|------|------|--------|----------|
| **T** | TIM2运行状态 | 1 | 0 = TIM2未启动，ADC无触发 |
| **E** | 外部触发使能 | 1 | 0 = ADC外部触发未使能 |
| **R** | 数据就绪标志 | 1 | 0 = DMA中断未触发，数据未更新 |
| **(48,51)** | 迟滞电压阈值 | 变量值 | 显示实际的VBUS_LOWER_THRESHOLD和VBUS_UPPER_THRESHOLD |
| **阈值含义** | - | - | 48V导通，51V关断 |

**正常工作时诊断标志必须全部为1**：`TER111(48,51)`
- 括号内的值显示实际配置的阈值变量

---

## 迟滞阈值配置

### 如何修改阈值

迟滞电压阈值定义在 `Core/Src/main.c` 文件中（第75-76行）：

```c
/* Voltage thresholds for hysteresis */
#define VBUS_UPPER_THRESHOLD 51.0f
#define VBUS_LOWER_THRESHOLD 48.0f
```

### 修改步骤

1. **打开文件**：`Core/Src/main.c`
2. **定位位置**：找到第75-76行的阈值定义
3. **修改数值**：
   - `VBUS_UPPER_THRESHOLD`：电压上限（超过此值关断）
   - `VBUS_LOWER_THRESHOLD`：电压下限（低于此值导通）
4. **保存文件**
5. **重新编译**：重新构建项目
6. **烧录固件**：将新固件烧录到STM32

### 修改示例

**示例1：提高上限到55V**
```c
#define VBUS_UPPER_THRESHOLD 55.0f  // 从51V改为55V
#define VBUS_LOWER_THRESHOLD 48.0f  // 保持48V不变
```
OLED显示：`TER111(48,55)`

**示例2：将迟滞区间从3V扩大到5V**
```c
#define VBUS_UPPER_THRESHOLD 52.0f  // 从51V改为52V
#define VBUS_LOWER_THRESHOLD 47.0f  // 从48V改为47V
```
OLED显示：`TER111(47,52)`

**示例3：使用45V和50V阈值**
```c
#define VBUS_UPPER_THRESHOLD 50.0f  // 上限50V
#define VBUS_LOWER_THRESHOLD 45.0f  // 下限45V
```
OLED显示：`TER111(45,50)`

### 注意事项

- **迟滞区间**：上限必须 > 下限，否则系统无法正常工作
- **浮点数格式**：阈值使用浮点数（例如 `51.0f`），支持小数精度
- **自动显示**：修改后OLED第4行会自动显示新的阈值
- **需要重编译**：修改阈值后必须重新编译和烧录才能生效

### 验证修改

修改完成后，通过以下方式验证：
1. 查看OLED第4行显示，确认括号内的值已更新
2. 调节输入电压，测试在新的阈值点是否正确切换状态
3. 确认迟滞区间内（下限到上限之间）状态不发生抖动

---

## 软件架构

### 系统框图

```
┌─────────────────────────────────────────────────────┐
│                   主循环 (1Hz OLED更新)              │
└─────────────────────────────────────────────────────┘
                          ↑
                          │
              ┌───────────┴───────────┐
              │   adc_data_ready=1?   │
              └───────────┬───────────┘
                          │
              ┌───────────▼───────────┐
              │  Process_Voltage_     │
              │  And_Control()        │
              │  - 计算DMA平均值      │
              │  - 16样本滑动平均     │
              │  - 电压转换           │
              │  - 迟滞判断           │
              │  - 更新GPIO/PWM       │
              └───────────────────────┘
                          ↑
                          │
┌─────────────┐   ┌──────┴───────┐
│  DMA1_Ch1   │   │ ADC1_2_IRQn  │
│  IRQ        │   │ IRQ          │
└──────┬──────┘   └──────┬───────┘
       │                 │
       └────────┬────────┘
                │
        ┌───────▼─────────┐
        │  ADC1 + DMA     │
        │  硬件循环传输   │
        └───────┬─────────┘
                │
        ┌───────▼─────────┐
        │  TIM2_CC2       │
        │  1kHz触发源     │
        └─────────────────┘
```

### 中断驱动架构

```
[硬件触发]          [DMA传输]          [主循环处理]
TIM2 CC2 ──→ ADC转换 ──→ DMA ──→ Set Flag ──→ Process
  1kHz      (硬件)      (自动)     (中断)       (主循环)
```

**关键原则**：
1. **ISR/DMA回调只设置标志**，不执行业务逻辑
2. **主循环执行所有计算和输出更新**
3. **OLED更新严格在主循环**，禁止在ISR中调用

### 代码文件结构

```
Core/
├── Src/
│   ├── main.c          # 主应用逻辑
│   ├── adc.c           # ADC配置（PA5/CH5，外部触发）
│   ├── dma.c           # DMA配置（循环模式）
│   ├── tim.c           # TIM2(触发)/TIM3_CH3(PWM/PB0)配置
│   ├── gpio.c          # GPIO配置（PA4控制输出）
│   ├── i2c.c           # I2C配置
│   ├── usart.c         # USART2配置（PA2/PA3，115200）
│   ├── oled.c          # SSD1306驱动
│   └── stm32f1xx_it.c  # 中断服务程序
├── Inc/
│   ├── usart.h         # USART2句柄声明
│   ├── oled.h
│   ├── oled_font.h     # 8x16字体数据（注意：小写文件名）
│   └── ...
```

---

## 构建和烧录

### 环境要求

- **IDE**：CLion 2025.3.2 + STM32CubeMX插件
- **工具链**：ARM GCC 13.3.1（STM32CubeCLT）
- **构建系统**：CMake + Ninja
- **调试器**：ST-Link V2/V3

### 构建步骤

#### 方法1：CLion IDE（推荐）

1. 打开项目根目录的`Vtest03.ioc`（STM32CubeMX）
2. CLion自动识别CMake配置
3. 点击"Build"或按`Ctrl+F9`

#### 方法2：命令行（使用CLion内置工具）

```bash
cd C:\STM32\Projects\Vtest03\Vtest03\build\Debug
"C:\Program Files\JetBrains\CLion 2025.3.2\bin\ninja\win\x64\ninja.exe"
```

#### 方法3：纯 IOC + CubeMX CLI（自动化推荐）

1. 仅修改 `Vtest03.ioc`（外设/引脚配置单一真源）
2. 运行无头生成脚本 `cube_headless.txt`
3. 用 CMake 构建验证

```bash
/Applications/STMicroelectronics/STM32CubeMX.app/Contents/MacOs/STM32CubeMX -q /Users/aidan/Documents/AI-system/Vtest03/cube_headless.txt
cmake --preset Debug
cmake --build build/Debug
```

**本项目注意**：
- 当前项目/版本下，`generate code <project_root>` 可能生成到 `Src/`、`Inc/`
- 构建系统实际使用 `Core/Src`、`Core/Inc`
- 因此 `cube_headless.txt` 统一使用 `project generate`

### 构建输出

成功构建后生成：
- `Vtest03.elf` - 可执行文件（带调试符号）
- `Vtest03.map` - 内存映射文件
- `build/Debug/` - 所有目标文件

### 烧录步骤

#### 使用ST-Link Utility

1. 连接ST-Link到STM32F103C8T6
2. 打开ST-Link Utility
3. File → Open File → 选择`Vtest03.elf`
4. Target → Program & Verify
5. 点击"Start"

#### 使用CLion调试器

1. 配置Run/Debug Configuration为"STM32 CMSIS-DAP Debugger"
2. 点击"Debug"按钮
3. 程序自动烧录并暂停在main()

---

## 工作原理

### 电压测量流程

1. **TIM2生成1kHz触发信号**
   - 时钟：72MHz
   - PSC=71, ARR=999 → 1kHz
   - CC2匹配时（CNT=1）触发ADC
   - 需手动置位 TIM2->CCER CC2E 位使能CC2事件

2. **ADC执行转换**
   - 外部触发源：TIM2_CC2
   - 采样时间：71.5周期
   - 分辨率：12位（0-4095）
   - 转换时间：约1μs @ 14MHz ADC时钟

3. **DMA自动传输数据**
   - 循环模式：8个样本缓冲区
   - 4个样本完成 → 半传输中断 → `HAL_ADC_ConvHalfCpltCallback()`
   - 8个样本完成 → 全传输中断 → `HAL_ADC_ConvCpltCallback()`
   - 两个中断都设置`adc_data_ready=1`

4. **主循环处理**
   - 检测到`adc_data_ready=1`
   - 计算8个样本平均值（DMA缓冲区）
   - **应用16样本滑动平均滤波器**（消除噪声）
   - 转换为电压：`Vbus = (adc_avg / 4095 × 3.3V) × 25`
   - 应用迟滞逻辑
   - 更新GPIO和PWM

### 软件滤波器原理

**算法**：滑动平均滤波器（Moving Average Filter）

```c
/* 滤波流程 */
每次DMA传输完成 → 计算8样本平均值 → 存入16样本环形缓冲区
                → 计算16样本滑动平均 → 用于电压计算
```

**关键参数**：
- **DMA采样**：8样本 @ 1kHz → 8ms周期
- **滤波窗口**：16样本 → 16ms总周期
- **内存占用**：32字节（16 × uint16_t）
- **响应延迟**：16ms（可接受）

**效果对比**：

| 情况 | 无滤波 | 有滤波 |
|------|--------|--------|
| **ADC悬空** | 0-4095乱跳 | 稳定在小范围内 |
| **恒定电压** | ±5 LSB波动 | ±1 LSB波动 |
| **电压变化** | 立即响应 | 16ms平滑过渡 |
| **噪声抑制** | 无 | 强（1/√16 = 1/4）**

### 迟滞保护逻辑

```c
if (vbus > 51.0V) {
    // 超压保护：关断
    Set_Output_State(STATE_CUTOFF);
} else if (vbus < 48.0V) {
    // 欠压恢复：导通
    Set_Output_State(STATE_CONDUCTION);
} else {
    // 48V-51V之间：维持当前状态（防抖）
    // 不做任何改变
}
```

**状态转换图**：
```
     vbus > 51V
    ┌───────────┐
    │           │
    ▼           │
┌──────┐    ┌──────┐
│CUTOFF│◄───┤CONDU │
└──────┘    └──────┘
    ▲           │
    │    vbus < 48V
    │           │
    └───────────┘
    48V-51V区间：保持当前状态
```

### 输出控制逻辑

#### CUTOFF状态（关断）
- **PA4** = HIGH（物理关断）
- **PWM（PB0）** = 100%占空比（TIM3 CCR3=7200，恒定HIGH）
- **双重保险**：任一输出为HIGH即关断

#### CONDUCTION状态（导通）
- **PA4** = LOW（物理导通）
- **PWM（PB0）** = 0%占空比（TIM3 CCR3=0，恒定LOW）
- **完全导通**：两个输出都确保LOW

---

## 故障排查

### OLED显示乱码或错位

**症状**：字符显示位置错误、部分字符丢失

**原因**：
- 字符串超过16字符宽度
- OLED清屏不完整

**解决**：
- 确保所有字符串≤16字符
- 检查`OLED_Clear()`是否在每次更新前调用

### ADC值显示为0，RDY=0

**症状**：`ADC:0`，`TER110(48,51)`

**原因**：
- TIM2未产生ADC触发信号
- DMA中断未配置

**解决**：
- 检查`tim.c`中`htim2.Instance->CCER |= TIM_CCER_CC2E;`
- 检查`adc.c`中`__HAL_DMA_ENABLE_IT(&hdma_adc1, DMA_IT_TC | DMA_IT_HT);`

### GPIO状态不随电压变化

**症状**：电压变化但State不变

**原因**：
- ADC数据未更新
- 迟滞区间内（48-51V）

**解决**：
- 检查第4行诊断信息`TER111(48,51)`
- 确认电压确实超出48-51V区间

### Vbus显示不完整

**症状**：只显示"V"或部分字符

**原因**：
- 使用了浮点格式化（%f）
- STM32 nano C库默认不支持

**解决**：
- 使用整数运算（已修复）
- 链接选项添加`-u _printf_float`启用浮点支持

### TIM2未启动（T:0）

**症状**：`TER011(48,51)` 或类似T位为0的显示

**原因**：
- `HAL_TIM_OC_Start()`未调用
- TIM2时钟未使能

**解决**：
- 检查`main.c`中启动顺序
- 检查`MX_TIM2_Init()`返回值

### ADC读数乱跳或悬空波动

**症状**：
- ADC引脚悬空时读数在0-4095之间随机跳动
- Vbus电压显示不稳定
- 系统状态频繁在ON/OFF之间切换

**原因**：
- **ADC引脚悬空**，高输入阻抗（MΩ级）捕获电磁噪声
- 分压电阻过大（R2>47kΩ），对地阻抗偏高
- 环境电磁干扰严重

**解决方案**（按优先级）：

#### 方案1：软件滤波（已实现，无需硬件改动）
✅ **推荐**：系统已内置16样本滑动平均滤波器
- 自动消除随机噪声
- 烧录最新固件即可
- 适用于所有场景

#### 方案2：添加硬件下拉电阻
**何时需要**：
- 分压电路中R2>47kΩ（高阻抗）
- 极高噪声环境（工业现场）
- 需要更强抗干扰能力

**电阻选型**：
```
正常情况（R2=10kΩ）：
  → 无需额外下拉，软件滤波足够

高阻抗情况（R2=100kΩ）：
  → 并联10kΩ下拉到GND
  → 等效阻抗：9.1kΩ

测试阶段（引脚悬空）：
  → 添加10kΩ下拉到GND
  → 或直接短接到GND测试
```

#### 方案3：双保险（硬件+软件）
**适用场景**：关键应用、恶劣环境
- 硬件：10kΩ下拉电阻
- 软件：16样本滑动平均滤波
- 效果：最优抗干扰性能

**快速测试**：
1. 烧录最新固件（含软件滤波）
2. PA5引脚悬空 → 读数应稳定在小范围内
3. 如仍有波动 → 添加10kΩ下拉到GND
4. 验证：PA5接地显示0，接3.3V显示约82.5V

---

## 技术规格

### 电气参数

| 参数 | 值 | 单位 |
|------|------|------|
| 工作电压 | 3.3 | V |
| ADC分辨率 | 12 | bit |
| ADC采样率 | 1 | kHz |
| 测量精度 | ±0.1 | V |
| PWM频率 | 10 | kHz |
| 迟滞电压 | 48-51 | V |

### 软件参数

| 参数 | 值 | 说明 |
|------|------|------|
| 主频 | 72 | MHz |
| ADC时钟 | 12 | MHz (PCLK2/6) |
| TIM2频率 | 1 | kHz (ADC触发) |
| TIM3频率 | 10 | kHz (PWM输出) |
| I2C速率 | 400 | kHz (Fast Mode) |
| OLED刷新率 | 1 | Hz |
| UART波特率 | 115200 | baud (USART2) |
| **DMA缓冲区** | 8 | 样本 @ 1kHz |
| **滤波窗口** | 16 | 样本 (16ms周期) |
| **滤波延迟** | 16 | ms |
| **PWM常量** | PWM_DUTY_CUTOFF/CONDUCTION | 使用HAL宏设置占空比 |

### 内存占用

```
RAM:   2176 B / 20 KB (10.62%)
FLASH: 37624 B / 64 KB (57.41%)
```

**RAM使用明细**：
- ADC DMA缓冲区：16字节（8 × uint16_t）
- 滤波器缓冲区：32字节（16 × uint16_t）
- 滤波器计数器：1字节（filter_count）
- 系统变量：约2.1KB

---

## 修改记录

### 关键修复历史

1. **DMA中断未触发**
   - 问题：`adc_data_ready`始终为0
   - 修复：显式使能`DMA_IT_TC | DMA_IT_HT`

2. **TIM2未触发ADC**
   - 问题：`ADC:0`，ADC未工作
   - 修复：
     - OC模式设为`TIM_OCMODE_TIMING`
     - 使能CC2输出：`TIM2->CCER |= TIM_CCER_CC2E`

3. **OLED显示错位**
   - 问题：字符串溢出导致回绕
   - 修复：所有字符串缩短至≤16字符

4. **Vbus显示不完整**
   - 问题：浮点格式化不支持
   - 修复：改用整数运算

5. **ADC读数乱跳/悬空波动**
   - 问题：ADC引脚悬空时读数在0-4095随机跳动
   - 原因：高输入阻抗捕获电磁噪声
   - 修复：实现16样本滑动平均滤波器
     - 滤波窗口：16样本（16ms周期）
     - 噪声抑制：1/√16 = 1/4
     - 内存占用：32字节
   - 效果：ADC读数稳定，悬空时波动大幅降低

6. **OLED显示格式优化**
   - 第4行改为 `TER111(48,51)` 紧凑格式，括号内显示实际阈值变量值
   - 第1-3行右侧增加 L/U/X 垂直标识，形成"LUX"字样

7. **引脚迁移**（✅ 当前版本）
   - ADC：PA0/CH0 → PA5/CH5
   - GPIO控制：PA1 → PA4（标签 POWER_CTRL）
   - PWM：TIM3_CH1/PA6 → TIM3_CH3/PB0（CCR1→CCR3）
   - 新增：USART2（PA2/PA3），115200波特率，printf调试输出
   - PA4 默认 HIGH 修复：通过 IOC `PA4.PinState=GPIO_PIN_SET` 直接生成安全默认态（不再依赖 USER CODE 覆写）

8. **oled_font.h 大小写修复**
   - 问题：Linux大小写敏感，`oled.c`引用`OLED_Font.h`但实际文件名为`oled_font.h`
   - 修复：`oled.c` 中改为 `#include "oled_font.h"`

9. **软件滤波器初始化修复**（✅ 当前版本）
   - 问题：原代码在 `filter_index == 0 && filtered_sum > 0` 时标记初始化完成，但此时缓冲区可能未满
   - 修复：使用独立计数器 `filter_count` 跟踪已填充样本数，确保缓冲区完全填满16个样本后才标记初始化完成
   - 效果：更稳定的滤波行为，避免初始化阶段的读数波动

10. **PWM占空比硬编码修复**（✅ 当前版本）
    - 问题：直接使用 `TIM3->CCR3 = 7200/0` 硬编码，可维护性差
    - 修复：
      - 定义常量 `PWM_DUTY_CUTOFF = 7200` 和 `PWM_DUTY_CONDUCTION = 0`
      - 使用 HAL 宏 `__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_3, value)` 替代直接寄存器操作
    - 效果：代码更易维护，修改 ARR 配置时只需更新常量定义

11. **CubeMX CLI 生成路径修复**（✅ 当前版本）
    - 问题：`generate code <project_root>` 在当前项目中可能落到 `Src/`、`Inc/`，导致构建仍使用旧的 `Core/Src`、`Core/Inc`
    - 修复：`cube_headless.txt` 统一采用 `project toolchain CMake` + `project name Vtest03` + `project generate`
    - 效果：IOC 修改会稳定落地到实际参与编译的源码目录

---

## 许可证

本项目遵循STM32CubeMX生成的代码许可证。

---

## 技术支持

如有问题，请检查：
1. OLED第4行诊断信息（`TER111(48,51)`）
2. 硬件连接是否正确
3. 分压电阻参数是否匹配

**关键诊断点**：
- `T:0` → TIM2问题
- `E:0` → ADC外部触发未使能
- `R:0` → DMA中断问题
- `(48,51)` → 迟滞阈值变量显示（显示VBUS_LOWER_THRESHOLD和VBUS_UPPER_THRESHOLD的实际值）

---

## 版本信息

- **硬件**：STM32F103C8T6
- **固件版本**：v2.1（滤波器初始化修复 + PWM常量化）
- **CubeMX版本**：6.16.1
- **HAL库**：STM32F1xx HAL Driver
- **最后更新**：2026-02-24
- **Flash占用**：37624 B / 64 KB (57.41%)
- **RAM占用**：2176 B / 20 KB (10.62%)
